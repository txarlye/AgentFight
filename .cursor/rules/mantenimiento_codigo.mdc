---
description: EstÃ¡ndares para mantenimiento del cÃ³digo - GestiÃ³n de archivos muertos y funciones no utilizadas
globs: ["**/*.py", "**/tests/**", "**/.borrar/**"]
alwaysApply: true
---

# MANTENIMIENTO DEL CÃ“DIGO

## ğŸš« PROHIBICIÃ“N DE SCRIPTS SUELTOS

### **NUNCA CREAR**:
- Scripts que no se llamen desde el flujo general del programa
- Archivos de prueba fuera de `tests/`
- Scripts de demo fuera de `tests/demos/` o `tests/`
- CÃ³digo que no tenga un propÃ³sito claro en el flujo principal

### **UBICACIÃ“N CORRECTA**:
- **Tests**: `tests/[categoria]/test_[nombre].py`
- **Demos**: `tests/demos/` o `tests/`
- **Scripts principales**: Solo en el flujo general del programa

## ğŸ—‚ï¸ GESTIÃ“N DE ARCHIVOS MUERTOS

### **Archivos No Utilizados**:
- **Mover a `.borrar/`** todos los archivos que no se llamen desde ningÃºn sitio
- **Verificar antes de mover** que realmente no se usan
- **Documentar el motivo** del movimiento si es necesario

### **Proceso de Limpieza**:
1. **Identificar archivos muertos**
2. **Verificar que no se referencian** en el cÃ³digo
3. **Mover a `.borrar/`** con comentario explicativo
4. **Actualizar documentaciÃ³n** si es necesario

## ğŸ”§ GESTIÃ“N DE FUNCIONES NO UTILIZADAS

### **Proceso Obligatorio para Funciones Muertas**:

#### **Paso 1: Renombrar con Sufijo de EliminaciÃ³n**
```python
# ANTES
def funcion_muerta():
    pass

# DESPUÃ‰S
def funcion_muerta_eliminar():
    pass
```

#### **Paso 2: Crear Test de VerificaciÃ³n**
```python
# tests/[categoria]/test_funcion_muerta_eliminar.py
"""
Test para verificar que la funciÃ³n marcada para eliminaciÃ³n
no rompe el sistema antes de eliminarla
"""

import unittest
import sys
import os

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

class TestFuncionEliminar(unittest.TestCase):
    def test_funcion_muerta_eliminar_no_rompe_sistema(self):
        """Verificar que eliminar la funciÃ³n no rompe el sistema"""
        # Test que verifica que el sistema sigue funcionando
        # sin la funciÃ³n marcada para eliminaciÃ³n
        pass

if __name__ == '__main__':
    unittest.main()
```

#### **Paso 3: Ejecutar Test y Verificar**
- **Ejecutar el test** para asegurar que no rompe nada
- **Verificar flujo general** del programa
- **Confirmar que no hay dependencias** ocultas

#### **Paso 4: Eliminar FunciÃ³n**
```python
# Eliminar completamente la funciÃ³n
# (ya no existe en el cÃ³digo)
```

### **Proceso de VerificaciÃ³n**:
1. **Renombrar funciÃ³n** con sufijo `_eliminar`
2. **Crear test especÃ­fico** para verificar impacto
3. **Ejecutar test** y verificar que no rompe
4. **Eliminar funciÃ³n** definitivamente
5. **Limpiar test** de verificaciÃ³n si es necesario

## âš ï¸ PROTOCOLO DE ADVERTENCIAS

### **Antes de Eliminar Cualquier FunciÃ³n**:
- **ADVERTIR** al usuario sobre la eliminaciÃ³n
- **Explicar el proceso** paso a paso
- **Mostrar el test** que se va a crear
- **Confirmar** que el usuario estÃ¡ de acuerdo

### **Mensaje de Advertencia**:
```
âš ï¸ FUNCIÃ“N MARCADA PARA ELIMINACIÃ“N

FunciÃ³n: [nombre_funcion]
UbicaciÃ³n: [archivo.py]
Proceso:
1. âœ… Renombrada a [nombre_funcion]_eliminar
2. ğŸ”„ Creando test de verificaciÃ³n...
3. â³ Ejecutando test...
4. â“ Â¿Proceder con la eliminaciÃ³n?

Â¿Continuar? (SÃ­/No)
```

## ğŸ“ ESTRUCTURA DE LIMPIEZA

### **Carpeta `.borrar/`**:
```
.borrar/
â”œâ”€â”€ archivos_muertos/
â”‚   â”œâ”€â”€ script_antiguo.py
â”‚   â””â”€â”€ demo_no_usado.py
â”œâ”€â”€ funciones_eliminadas/
â”‚   â””â”€â”€ backup_funciones_eliminadas.txt
â””â”€â”€ README_limpieza.md
```

### **DocumentaciÃ³n de Limpieza**:
```markdown
# Archivos Movidos a .borrar/

## Fecha: [fecha]
## Motivo: [razÃ³n del movimiento]

### Archivos Movidos:
- `archivo1.py` - No se llama desde ningÃºn sitio
- `archivo2.py` - Reemplazado por nueva implementaciÃ³n

### Funciones Eliminadas:
- `funcion1()` - No utilizada en el flujo principal
- `funcion2()` - Reemplazada por funciÃ³n mejorada
```

## âœ… CHECKLIST DE LIMPIEZA

### **Para Archivos**:
- [ ] Â¿Se llama desde el flujo principal?
- [ ] Â¿Tiene dependencias activas?
- [ ] Â¿Es necesario para el funcionamiento?
- [ ] Â¿Se puede mover a `.borrar/`?

### **Para Funciones**:
- [ ] Â¿Se usa en el flujo principal?
- [ ] Â¿Tiene dependencias ocultas?
- [ ] Â¿Se puede renombrar a `_eliminar`?
- [ ] Â¿Se puede crear test de verificaciÃ³n?
- [ ] Â¿Se puede eliminar sin romper el sistema?

## ğŸš€ COMANDOS ÃšTILES

### **Buscar Archivos No Utilizados**:
```bash
# Buscar archivos Python que no se importan
grep -r "import.*archivo" . --include="*.py" | grep -v "archivo.py"
```

### **Buscar Funciones No Utilizadas**:
```bash
# Buscar funciones que no se llaman
grep -r "funcion_nombre" . --include="*.py" | grep -v "def funcion_nombre"
```

### **Crear Test de VerificaciÃ³n**:
```python
# Template para test de funciÃ³n a eliminar
def test_funcion_eliminar_verificacion():
    """Verificar que eliminar la funciÃ³n no rompe el sistema"""
    # Test especÃ­fico para la funciÃ³n marcada
    pass
```

## ğŸ¯ PRINCIPIOS DE MANTENIMIENTO

### âœ… **SÃ HACER**:
- **Mover archivos muertos** a `.borrar/`
- **Renombrar funciones** antes de eliminar
- **Crear tests** de verificaciÃ³n
- **Advertir** antes de eliminar
- **Documentar** el proceso de limpieza

### âŒ **NO HACER**:
- **Eliminar directamente** sin verificar
- **Crear scripts sueltos** fuera del flujo
- **Ignorar dependencias** ocultas
- **Saltarse el proceso** de verificaciÃ³n

---

**Esta regla define los estÃ¡ndares para mantener el cÃ³digo limpio y organizado en el proyecto iaBoletin.**